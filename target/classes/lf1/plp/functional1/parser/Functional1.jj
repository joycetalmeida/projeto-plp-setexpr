options
{
  //  LOOKAHEAD = 6;
  //  FORCE_LA_CHECK = true;
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(Func1Parser)
package lf1.plp.functional1.parser;

// Imports da LF1 original
import lf1.plp.functional1.*;
import lf1.plp.functional1.declaration.DecVariavel;
import lf1.plp.functional1.declaration.DeclaracaoFuncional;
import lf1.plp.functional1.declaration.DecFuncao;
import lf1.plp.functional1.declaration.DecComposta;
import lf1.plp.functional1.expression.ExpDeclaracao;
import lf1.plp.functional1.expression.IfThenElse;
import lf1.plp.functional1.expression.Aplicacao;
import java.util.*;
import lf1.plp.expressions2.expression.ExpAnd;
import lf1.plp.expressions2.expression.ExpConcat;
import lf1.plp.expressions2.expression.ExpEquals;
import lf1.plp.expressions2.expression.ExpLength;
import lf1.plp.expressions2.expression.ExpMenos;
import lf1.plp.expressions2.expression.ExpNot;
import lf1.plp.expressions2.expression.ExpOr;
import lf1.plp.expressions2.expression.ExpSoma;
import lf1.plp.expressions2.expression.ExpSub;
import lf1.plp.expressions2.expression.ExpMult;
import lf1.plp.expressions2.expression.ExpDiv;
import lf1.plp.expressions2.expression.ExpRem;
import lf1.plp.expressions2.expression.ExpGt;
import lf1.plp.expressions2.expression.ExpLt;
import lf1.plp.expressions2.expression.ExpGe;
import lf1.plp.expressions2.expression.ExpLe;
import lf1.plp.expressions2.expression.ExpNe;
import lf1.plp.expressions2.expression.Expressao;
import lf1.plp.expressions2.expression.Id;
import lf1.plp.expressions2.expression.Valor;
import lf1.plp.expressions2.expression.ValorBooleano;
import lf1.plp.expressions2.expression.ValorInteiro;
import lf1.plp.expressions2.expression.ValorString;

// --- ADICIONADO: Imports para as novas classes de Conjunto ---
import lf1.plp.functional1.expression.set.ExpLiteralSet;
import lf1.plp.functional1.expression.set.ExpRange;
import lf1.plp.functional1.expression.set.ExpMap;
import lf1.plp.functional1.expression.set.ExpFilter;
import lf1.plp.functional1.expression.set.ExpUniao;
import lf1.plp.functional1.expression.set.ExpIntersecao;
import lf1.plp.functional1.expression.set.ExpDiferenca;
import lf1.plp.functional1.expression.set.ExpIn;
import lf1.plp.functional1.expression.set.ExpSubset;
import lf1.plp.functional1.expression.set.ExpCardinalidade;
import lf1.plp.functional1.expression.set.ExpUniaoDistribuida;
import lf1.plp.functional1.expression.set.ExpIntersecaoDistribuida;
import lf1.plp.functional1.expression.set.ValorConjunto; // Import para o main
import lf1.plp.functional1.expression.set.ExpPowerSet;
// --- FIM DOS IMPORTS ADICIONADOS ---

public class Func1Parser
{
  // ... (main original modificado para SetExpr) ...
  public static void main(String args [])
  {
    Func1Parser parser;
    if (args.length == 0)
    {
      System.out.println("SetExpr PLP Parser Version 0.0.1:  Reading from standard input . . .");
      parser = new Func1Parser(System.in);
    }
    else if (args.length == 1)
    {
      System.out.println("SetExpr PLP Parser Version 0.0.1:  Reading from file " + args [0] + " . . .");
      try
      {
        parser = new Func1Parser(new java.io.FileInputStream(args [0]));
      }
      catch (java.io.FileNotFoundException e)
      {
        System.out.println("SetExpr PLP Parser Version 0.0.1:  File " + args [0] + " not found.");
        return;
      }
    }
    else
    {
      System.out.println("SetExpr PLP Parser Version 0.0.1:  Usage is one of:");
      System.out.println("         java Func1Parser < inputfile");
      System.out.println("OR");
      System.out.println("         java Func1Parser inputfile");
      return;
    }
    Programa programa = null;
    try
    {
      programa = parser.Input();
      if (!programa.checaTipo())
 	  {
 	    System.out.println("SetExpr PLP Parser Version 0.0.1: Erro de tipo.");
      	System.exit(0);
      }
      System.out.println("SetExpr PLP Parser Version 0.0.1: SetExpr program parsed successfully.");
    }
    catch (ParseException e)
    {
      e.printStackTrace();
      System.out.println("SetExpr PLP Parser Version 0.0.1: Encountered errors during parse.");
      System.exit(0);
    }
    try
    {
      System.out.println("SetExpr PLP Parser Version 0.0.1: running...");
      Valor val = programa.executar();
      
      // --- ADICIONADO: Suporte para imprimir ValorConjunto ---
      if (val instanceof lf1.plp.functional1.expression.set.ValorConjunto)
      {
        System.out.println("SetExpr PLP Parser Version 0.0.1: resultado=" + val);
      }
      // --- FIM DA ADIÇÃO ---
      else if (val instanceof ValorString)
      {
        ValorString valStr = (ValorString) val;
        System.out.println("SetExpr PLP Parser Version 0.0.1: resultado=" + valStr.valor());
      }
      else if (val instanceof ValorInteiro)
      {
        ValorInteiro valInt = (ValorInteiro) val;
        System.out.println("SetExpr PLP Parser Version 0.0.1: resultado=" + valInt.valor());
      }
      else if (val instanceof ValorBooleano)
      {
        ValorBooleano valBool = (ValorBooleano) val;
        System.out.println("SetExpr PLP Parser Version 0.0.1: resultado=" + valBool.valor());
      }
      else 
      {
        System.out.println("SetExpr PLP Parser Version 0.0.1: resultado=" + val);
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
      System.out.println("SetExpr PLP Parser Version 0.0.1:  Encountered errors during execution.");
    }
  }
}

PARSER_END(Func1Parser)

// ... (SKIP e SPECIAL_TOKEN permanecem os mesmos) ...
SKIP : { " " | "\t" | "\n" | "\r" | "\f" }
SPECIAL_TOKEN : { <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> | <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/"> | <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/"> }


TOKEN : /* TOKENS DE FUNCIONAL 1 */
{
  < AND : "and" >
| < OR : "or" >
| < NOT : "not" >
| < LENGTH : "length" >
| < TRUE : "true" >
| < FALSE : "false" >
| < LET : "let" >
| < VAR : "var" >
| < IN : "in" > // Usado apenas no 'let ... in ...'
| < IF : "if" >
| < THEN : "then" >
| < ELSE : "else" >
| < FUNC : "fun" >
}

// --- ADICIONADO: TOKENS DE CONJUNTO ---
TOKEN : /* TOKENS DE SETEXPR */
{
  < UNION: "union" >
| < INTER: "inter" >
| < DIFF: "diff" >
| < SUBSET: "subset" >
| < NUMBER: "#" >
| < RANGE: ".." >
| < IS_IN: "isin" >
| < POWERSET: "powerset" >
| < D_UNION: "UNION" > // União Distribuída
| < D_INTER: "INTER" > // Interseção Distribuída
}
// --- FIM DOS TOKENS ADICIONADOS ---


TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL :
    < DECIMAL_LITERAL > ([ "l", "L" ])?
  | < HEX_LITERAL > ([ "l", "L" ])?
  | < OCTAL_LITERAL > ([ "l", "L" ])? >
| < #DECIMAL_LITERAL : ("0" | [ "1"-"9" ] ([ "0"-"9" ])*) > 
| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >
| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
| < STRING_LITERAL :
    "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        )
      )
    )*
    "\"" >
}

// ... (TOKEN: IDENTIFIERS e TOKEN: SEPARATORS permanecem os mesmos) ...
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "\u0024", "\u0041"-"\u005a", "\u005f", "\u0061"-"\u007a", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff" ] >
| < #DIGIT : [ "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049" ] >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN : "=" >
| < GT : ">" >
| < LT : "<" >
| < BANG : "!" >
| < TILDE : "~" >
| < HOOK : "?" >
| < COLON : ":" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NE : "!=" >
| < SC_OR : "||" >
| < SC_AND : "&&" >
| < CONCAT : "++" >
| < PLUS : "+" >
| < MINUS : "-" >
| < STAR : "*" >
| < SLASH : "/" >
| < BIT_AND : "&" >
| < BIT_OR : "|" >
| < XOR : "^" >
| < REM : "%" >
}

Programa Input() :
{
  Programa retorno;
}
{
  retorno = PPrograma() < EOF >
  {
    return retorno;
  }
}

// ... (PValorInteiro, PValorBooleano, PValorString, PValor, PId permanecem os mesmos) ...
Valor PValorInteiro() : { Token token; } { token = <INTEGER_LITERAL> { return new ValorInteiro(Integer.parseInt(token.toString())); } }
Valor PValorBooleano() : {} { <FALSE> { return new ValorBooleano(false); } | <TRUE> { return new ValorBooleano(true); } }
Valor PValorString() : { Token token; } { token = <STRING_LITERAL> { String tokenStr = token.toString(); tokenStr = tokenStr.substring(1, tokenStr.length() - 1); return new ValorString(tokenStr); } }
Valor PValor() : { Valor retorno; } { ( retorno = PValorInteiro() | retorno = PValorBooleano() | retorno = PValorString() ) { return retorno; } }
Id PId() : { Token token; } { token = <IDENTIFIER> { String tokenStr = token.toString(); return new Id(tokenStr); } }


// ... (PExpMenos, PExpNot, PExpLength permanecem os mesmos) ...
Expressao PExpMenos() : { Expressao retorno; } { <MINUS> retorno = PExpPrimaria() { return new ExpMenos(retorno); } }
Expressao PExpNot() : { Expressao retorno; } { <NOT> retorno = PExpPrimaria() { return new ExpNot(retorno); } }
Expressao PExpLength() : { Expressao retorno; } { <LENGTH> retorno = PExpPrimaria() { return new ExpLength(retorno); } }


// --- ADICIONADO: Regras unárias de Conjunto ---
Expressao PExpCardinalidade() : { Expressao retorno; } { <NUMBER> retorno = PExpPrimaria() { return new ExpCardinalidade(retorno); } }
Expressao PExpPowerSet() : { Expressao retorno; } { < POWERSET > retorno = PExpPrimaria() { return new ExpPowerSet(retorno); } }
Expressao PExpUniaoDistribuida() : { Expressao retorno; } { <D_UNION> retorno = PExpPrimaria() { return new ExpUniaoDistribuida(retorno); } }
Expressao PExpIntersecaoDistribuida() : { Expressao retorno; } { <D_INTER> retorno = PExpPrimaria() { return new ExpIntersecaoDistribuida(retorno); } }
// --- FIM DAS ADIÇÕES ---


Expressao PExpPrimaria() :
{
  Expressao retorno;
}
{
  (
    retorno = PValor()
  | retorno = PId()
  
  // --- CORREÇÃO DE RECURSÃO: Regra do Range movida para PExpRange ---
  | <LBRACE> retorno = PConjunto() // Regra para { ... }
  // --- FIM DA CORREÇÃO ---
  
  | < LPAREN > retorno = PExpressao() < RPAREN >
  )
  {
    return retorno;
  }
}

// --- ADICIONADO: Funções auxiliares para Conjuntos ---
// (PRange foi removido daqui e substituído por PExpRange na hierarquia)

// Função para tratar tudo que começa com {
Expressao PConjunto() :
{
  Expressao e1, e2;
  Id id;
  List<Expressao> elems;
}
{
  <RBRACE> // Caso 1: Conjunto vazio {}
  { return new ExpLiteralSet(new ArrayList<Expressao>()); }
| LOOKAHEAD(PExpressao() <COLON> <IDENTIFIER> <IN>) // Caso 2: Map {x*x : x in S}
  e1 = PExpressao() <COLON> id = PId() <IN> e2 = PExpressao() <RBRACE>
  { return new ExpMap(e1, id, e2); }
| LOOKAHEAD(<IDENTIFIER> <IN>) // Caso 3: Filter {x in S : x > 2}
  id = PId() <IN> e1 = PExpressao() <COLON> e2 = PExpressao() <RBRACE>
  { return new ExpFilter(id, e1, e2); }
| elems = PListaExp() <RBRACE> // Caso 4: Literal {1, 2, 3}
  { return new ExpLiteralSet(elems); }
}

// Função para analisar lista de expressões (para literais de conjunto e aplicação de função)
List PListaExp() :
{
  List<Expressao> retorno = new ArrayList<Expressao>();
  Expressao e;
}
{
  ( // --- MODIFICADO: Torna a lista de expressões opcional ---
    e = PExpressao() { retorno.add(e); }
    (
      <COMMA> e = PExpressao() { retorno.add(e); }
    )*
  )?
  { return retorno; }
}
// --- FIM DAS FUNÇÕES ADICIONADAS ---


List PListaId() :
{
  List < Id > retorno = null;
  Id id;
}
{
  (
    id = PId()
    {
      if (retorno == null)
      {
        retorno = new ArrayList < Id > ();
        retorno.add(id);
      }
      else
      {
        retorno.add(id);
      }
    }
  )*
  {
    return retorno;
  }
}

// ... (PDeclVar, PDeclFuncao, PDecComposta, PDeclFuncional, PExpDeclaracao, PExpCondicional permanecem os mesmos) ...
DeclaracaoFuncional PDeclVar() : { Id id; Expressao expressao; DeclaracaoFuncional retorno; } { ( <VAR> id = PId() <ASSIGN> expressao = PExpressao() ) { return new DecVariavel(id, expressao); } }
DeclaracaoFuncional PDeclFuncao() : { Id id; Expressao expressao; DeclaracaoFuncional retorno; List <Id> lista; } { ( <FUNC> id = PId() lista = PListaId() <ASSIGN> expressao = PExpressao() ) { return new DecFuncao(id, lista, expressao); } }
DecComposta PDecComposta() : { DeclaracaoFuncional d1; DeclaracaoFuncional d2; } { ( d1 = PDeclVar() | d1 = PDeclFuncao() ) <COMMA> d2 = PDeclFuncional() {return new DecComposta(d1, d2);} }
DeclaracaoFuncional PDeclFuncional() : { DeclaracaoFuncional decl; } { ( LOOKAHEAD(PDeclVar() <COMMA>) decl = PDecComposta() | LOOKAHEAD(PDeclFuncao() <COMMA>) decl = PDecComposta() | decl = PDeclVar() | decl = PDeclFuncao() | <LPAREN> decl = PDeclFuncional() <RPAREN> ) { return decl; } }
Expressao PExpDeclaracao() : { DeclaracaoFuncional declaracoes; Expressao expressao; } { <LET> declaracoes = PDeclFuncional() <IN> expressao = PExpressao() { return new ExpDeclaracao(declaracoes, expressao); } }
Expressao PExpCondicional() : { Expressao expCond, expThen, expElse; } { <IF> expCond = PExpressao() <THEN> expThen = PExpressao() <ELSE> expElse = PExpressao() { return new IfThenElse(expCond, expThen, expElse); } }


Expressao PAplicacao() :
{
  List expressoes = null;
  Id id;
}
{
  (
    id = PId() < LPAREN > 
    // --- MODIFICADO: para usar PListaExp (que agora suporta lista vazia) ---
    expressoes = PListaExp()
    < RPAREN >
  )
  {
    return new Aplicacao(id, expressoes);
  }
}

Expressao PExpUnaria() :
{
  Expressao retorno;
}
{
  (
    LOOKAHEAD(PExpMenos())
    retorno = PExpMenos()
  | LOOKAHEAD(PExpNot())
    retorno = PExpNot()
  | LOOKAHEAD(PExpLength())
    retorno = PExpLength()
    
  // --- ADICIONADO: Regras unárias de Conjunto ---
  | LOOKAHEAD(PExpCardinalidade())
    retorno = PExpCardinalidade()
  | LOOKAHEAD(PExpPowerSet())
    retorno = PExpPowerSet()
  | LOOKAHEAD(PExpUniaoDistribuida())
    retorno = PExpUniaoDistribuida()
  | LOOKAHEAD(PExpIntersecaoDistribuida())
    retorno = PExpIntersecaoDistribuida()
  // --- FIM DA ADIÇÃO ---
  
  | LOOKAHEAD(PExpDeclaracao())
    retorno = PExpDeclaracao()
  | LOOKAHEAD(PExpCondicional())
    retorno = PExpCondicional()
  | LOOKAHEAD(PId() < LPAREN >)
    retorno = PAplicacao()
    
  // --- CORREÇÃO DE RECURSÃO: A regra "default" agora é PExpRange ---
  | retorno = PExpRange() 
  // --- FIM DA CORREÇÃO ---
  )
  {
    return retorno;
  }
}

// --- ADICIONADO: Nova regra PExpRange para quebrar a recursão ---
Expressao PExpRange() :
{
  Expressao e1, e2;
}
{
  e1 = PExpPrimaria() // Analisa a expressão primária da esquerda
  (
    <RANGE> e2 = PExpPrimaria() // Se encontrar ".."
    { return new ExpRange(e1, e2); } // Cria um ExpRange
  )? // O '?' significa que o range é opcional
  
  { return e1; } // Se não houver range, retorna a expressão primária que leu
}
// --- FIM DA ADIÇÃO ---

Expressao PExpBinaria() :
{
  Expressao retorno, param2;
}
{
  (
    retorno = PExpRelacional()
    (
      < EQ > param2 = PExpRelacional()
      {
        retorno = new ExpEquals(retorno, param2);
      }
    | < NE > param2 = PExpRelacional()
      {
        retorno = new ExpNe(retorno, param2);
      }
    )*
  )
  {
    return retorno;
  }
}

// --- ADICIONADO: Regra para operadores relacionais ---
Expressao PExpRelacional() :
{
  Expressao retorno, param2;
}
{
  (
    retorno = PExpBinaria2()
    (
      < LT > param2 = PExpBinaria2()
      {
        retorno = new ExpLt(retorno, param2);
      }
    | < GT > param2 = PExpBinaria2()
      {
        retorno = new ExpGt(retorno, param2);
      }
    | < LE > param2 = PExpBinaria2()
      {
        retorno = new ExpLe(retorno, param2);
      }
    | < GE > param2 = PExpBinaria2()
      {
        retorno = new ExpGe(retorno, param2);
      }
    )*
  )
  {
    return retorno;
  }
}
// --- FIM DA ADIÇÃO ---

Expressao PExpBinaria2() :
{
  Expressao retorno, param2;
}
{
  (
    retorno = PExpBinariaSet() // --- MODIFICADO: Chama a nova regra de conjunto ---
    (
      < PLUS > param2 = PExpBinariaSet() // --- MODIFICADO ---
      {
        retorno = new ExpSoma(retorno, param2);
      }
    | < MINUS > param2 = PExpBinariaSet() // --- MODIFICADO ---
      {
        retorno = new ExpSub(retorno, param2);
      }
    | < OR > param2 = PExpBinariaSet() // --- MODIFICADO ---
      {
        retorno = new ExpOr(retorno, param2);
      }
    | < CONCAT > param2 = PExpBinariaSet() // --- MODIFICADO ---
      {
        retorno = new ExpConcat(retorno, param2);
      }
    )*
  )
  {
    return retorno;
  }
}

// --- ADICIONADO: Nova regra para operadores de conjunto binários ---
Expressao PExpBinariaSet() :
{
  Expressao retorno, param2;
}
{
  (
    retorno = PExpMultiplicativa() // Chama a próxima regra na cadeia (multiplicativos)
    (
      <UNION> param2 = PExpMultiplicativa()
      { retorno = new ExpUniao(retorno, param2); }
    | <INTER> param2 = PExpMultiplicativa()
      { retorno = new ExpIntersecao(retorno, param2); }
    | <DIFF> param2 = PExpMultiplicativa()
      { retorno = new ExpDiferenca(retorno, param2); }
    | <IS_IN> param2 = PExpMultiplicativa()
      { retorno = new ExpIn(retorno, param2); }
    | <SUBSET> param2 = PExpMultiplicativa()
      { retorno = new ExpSubset(retorno, param2); }
    )*
  )
  {
    return retorno;
  }
}
// --- FIM DA ADIÇÃO ---

// --- ADICIONADO: Regra para operadores multiplicativos ---
Expressao PExpMultiplicativa() :
{
  Expressao retorno, param2;
}
{
  (
    retorno = PExpBinaria3() // Chama a próxima regra na cadeia (AND)
    (
      < STAR > param2 = PExpBinaria3()
      {
        retorno = new ExpMult(retorno, param2);
      }
    | < SLASH > param2 = PExpBinaria3()
      {
        retorno = new ExpDiv(retorno, param2);
      }
    | < REM > param2 = PExpBinaria3()
      {
        retorno = new ExpRem(retorno, param2);
      }
    )*
  )
  {
    return retorno;
  }
}
// --- FIM DA ADIÇÃO ---


Expressao PExpBinaria3() :
{
  Expressao retorno, param2;
}
{
  (
    retorno = PExpUnaria()
    (
      < AND > param2 = PExpUnaria()
      {
        retorno = new ExpAnd(retorno, param2);
      }
    )*
  )
  {
    return retorno;
  }
}

Expressao PExpressao() :
{
  Expressao retorno;
}
{
  retorno = PExpBinaria()
  {
    return retorno;
  }
}

Programa PPrograma() :
{
  Expressao retorno;
}
{
  retorno = PExpressao()
  {
    return new Programa(retorno);
  }
}